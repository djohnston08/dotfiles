#########################################
# Utility Functions

###
# some echo helpers
# @author Adam Eivy
###

# Colors
ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"
COL_BLUE=$ESC_SEQ"34;01m"
COL_MAGENTA=$ESC_SEQ"35;01m"
COL_CYAN=$ESC_SEQ"36;01m"

function ok() {
    echo -e "$COL_GREEN[ok]$COL_RESET "$1
}

function bot() {
    echo
    echo -e "$COL_GREEN\[._.]/$COL_RESET - "$1
}

function running() {
    echo -en " ⇒ "$1"..."
}

function action() {
    echo -e "$COL_YELLOW[action]$COL_RESET"
    running $1"..."
}

function warn() {
    echo -e "$COL_YELLOW[warning]$COL_RESET "$1
}

function error() {
    echo -e "$COL_RED[error]$COL_RESET "$1
}

# Create a new git repo with one README commit and CD into it
function gitnr() {
    mkdir $1
    cd $1
    git init
    touch README
    git add README
    git commit -mFirst-commit
}

# Do a Matrix movie effect of falling characters
function matrix1() {
    echo -e "\e[1;40m"
    clear
    while :; do
        echo $LINES $COLUMNS $(($RANDOM % $COLUMNS)) $(($RANDOM % 72))
        sleep 0.05
    done | gawk '{ letters="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()"; c=$4; letter=substr(letters,c,1);a[$3]=0;for (x in a) {o=a[x];a[x]=a[x]+1; printf "\033[%s;%sH\033[2;32m%s",o,x,letter; printf "\033[%s;%sH\033[1;37m%s\033[0;0H",a[x],x,letter;if (a[x] >= $1) { a[x]=0; } }}'
}

function matrix2() {
    echo -e "\e[1;40m"
    clear
    characters=$(jot -c 94 33 | tr -d '\n')
    while :; do
        echo $LINES $COLUMNS $(($RANDOM % $COLUMNS)) $(($RANDOM % 72)) $characters
        sleep 0.05
    done | gawk '{ letters=$5; c=$4; letter=substr(letters,c,1);a[$3]=0;for (x in a) {o=a[x];a[x]=a[x]+1; printf "\033[%s;%sH\033[2;32m%s",o,x,letter; printf "\033[%s;%sH\033[1;37m%s\033[0;0H",a[x],x,letter;if (a[x] >= $1) { a[x]=0; } }}'
}

function setproj() {
    echo "###############"
    echo "##  \[._.]/  ##"
    echo "###############"
    bot "Hi, this workspace is setup for the $1 project"
}

function fixperms() {
    find . \( -name "*.sh" -or -type d \) -exec chmod 755 {} \; && find . -type f ! -name "*.sh" -exec chmod 644 {} \;
}

## curlheader will return the header value specified for a given URL
## usage: curlheader ${header} ${url}
## or get all headers
## curlheader ${url}
function curlheader() {
    if [[ -z "$2" ]]; then
        echo "curl -k -s -D - $1 -o /dev/null"
        curl -k -s -D - $1 -o /dev/null:
    else
        echo "curl -k -s -D - $2 -o /dev/null | grep $1:"
        curl -k -s -D - $2 -o /dev/null | grep $1:
    fi
}

## hammer a service with curl for a given number of times
function curlhammer() {
    bot "about to hammer $1 with $2 curls ⇒"
    echo "curl -k -s -D - $1 -o /dev/null | grep 'HTTP/1.1' | sed 's/HTTP\/1.1 //'"
    for i in {1..$2}; do
        curl -k -s -D - $1 -o /dev/null | grep 'HTTP/1.1' | sed 's/HTTP\/1.1 //'
    done
    bot "done"
}

function hasSail() {
    if [ -f sail ]; then
        return 0
    fi

    if [ -f vendor/bin/sail ]; then
        return 0
    fi

    return 1
}

# Smart worktree creation with tmux integration
function gwt-smart() {
    local branch=$1
    local base=${2:-$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | cut -d'/' -f4 || echo "main")}
    local repo_root=$(git rev-parse --show-toplevel)
    local repo_name=$(basename "$repo_root")
    local is_bare=$(git rev-parse --is-bare-repository)
    
    # Determine worktree path
    local worktree_path
    if [[ "$is_bare" == "true" ]]; then
        # For bare repos, create at the root level
        worktree_path="$branch"
    else
        # For normal repos, create as sibling directory
        worktree_path="../${branch}"
    fi

    echo "Creating worktree: $worktree_path from branch: $base"
    git worktree add -b "$branch" "$worktree_path" "$base"
    
    # Get the actual worktree directory
    local actual_path
    if [[ "$is_bare" == "true" ]]; then
        actual_path="$(dirname "$repo_root")/$branch"
    else
        actual_path="$(dirname "$repo_root")/${repo_name}-${branch}"
    fi
    
    cd "$actual_path"

    # Auto-create tmux session if tmux is available
    if command -v tmux &>/dev/null && [ -n "$TMUX" ]; then
        local session_name="${repo_name}-${branch}"
        tmux new-session -d -s "$session_name" -c "$actual_path"
        tmux switch-client -t "$session_name" 2>/dev/null
    fi
}

# Enhanced worktree switching
function gwt-switch() {
    local worktree=$(git worktree list | fzf | awk '{print $1}')
    if [[ -n "$worktree" ]]; then
        cd "$worktree"
        echo "Switched to worktree: $worktree"
    fi
}

# Clean up merged worktrees
function gwt-cleanup() {
    git worktree list | grep -v "bare)" | while read -r line; do
        local path=$(echo "$line" | awk '{print $1}')
        local branch=$(echo "$line" | awk '{print $3}' | tr -d '[]')

        if [[ "$branch" != "main" && "$branch" != "master" && "$branch" != "develop" ]]; then
            echo "Checking if branch '$branch' is merged..."
            if git branch --merged main | grep -q "$branch"; then
                echo "Removing merged worktree: $path"
                git worktree remove "$path"
            fi
        fi
    done
}

# Convert existing repo to bare repo with worktrees
function gwt-convert-to-bare() {
    local repo_root=$(git rev-parse --show-toplevel)
    local repo_name=$(basename "$repo_root")
    local parent_dir=$(dirname "$repo_root")
    local current_branch=$(git branch --show-current)
    
    echo "Converting $repo_name to bare repository..."
    
    # Create a new bare clone
    cd "$parent_dir"
    mv "$repo_name" "${repo_name}-backup"
    git clone --bare "${repo_name}-backup/.git" "${repo_name}"
    
    # Add the current branch as a worktree
    cd "${repo_name}"
    git worktree add "$current_branch" "$current_branch"
    
    echo "Conversion complete!"
    echo "Original repo backed up to: ${repo_name}-backup"
    echo "New bare repo at: ${parent_dir}/${repo_name}"
    echo "Working tree at: ${parent_dir}/${repo_name}/${current_branch}"
    
    cd "$current_branch"
}
